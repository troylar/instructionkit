"""Utilities for .env file manipulation."""

import re
from pathlib import Path

from dotenv import dotenv_values, set_key

from aiconfigkit.core.models import EnvironmentConfig, InstallationScope
from aiconfigkit.utils.atomic_write import atomic_write


def load_env_config(env_path: Path, scope: InstallationScope) -> EnvironmentConfig:
    """
    Load environment configuration from .env file.

    Args:
        env_path: Path to .env file
        scope: Installation scope (PROJECT or GLOBAL)

    Returns:
        EnvironmentConfig object with loaded variables
    """
    variables: dict[str, str] = {}
    if env_path.exists():
        raw_variables = dotenv_values(str(env_path))
        # Filter out None values (empty vars) and ensure all values are strings
        variables = {k: str(v) for k, v in raw_variables.items() if v is not None}

    return EnvironmentConfig(variables=variables, file_path=str(env_path), scope=scope)


def save_env_config(env_config: EnvironmentConfig) -> None:
    """
    Save environment configuration to .env file using atomic write.

    Args:
        env_config: EnvironmentConfig to save
    """
    if not env_config.file_path:
        raise ValueError("EnvironmentConfig must have file_path set")

    env_path = Path(env_config.file_path)
    env_path.parent.mkdir(parents=True, exist_ok=True)

    # Ensure .gitignore exists for .env file
    ensure_env_gitignored(env_path)

    # Write .env file atomically
    with atomic_write(env_path, mode="w", encoding="utf-8", create_backup=True) as f:
        f.write("# MCP Server Credentials\n")
        f.write("# Auto-generated by InstructionKit\n")
        f.write("# DO NOT commit this file to version control\n\n")

        for key, value in sorted(env_config.variables.items()):
            # Escape newlines and quotes in values
            escaped_value = value.replace("\\", "\\\\").replace("\n", "\\n").replace('"', '\\"')
            f.write(f'{key}="{escaped_value}"\n')


def set_env_variable(env_path: Path, key: str, value: str) -> None:
    """
    Set a single environment variable in .env file.

    Uses python-dotenv's set_key for safe updating.

    Args:
        env_path: Path to .env file
        key: Variable name (must be UPPERCASE_WITH_UNDERSCORES)
        value: Variable value
    """
    # Validate key format
    if not re.match(r"^[A-Z][A-Z0-9_]*$", key):
        raise ValueError(f"Invalid environment variable name: {key}. Must match ^[A-Z][A-Z0-9_]*$")

    env_path.parent.mkdir(parents=True, exist_ok=True)

    # Ensure .gitignore exists
    ensure_env_gitignored(env_path)

    # Use python-dotenv's set_key for safe update
    set_key(str(env_path), key, value, quote_mode="always")


def ensure_env_gitignored(env_path: Path) -> None:
    """
    Ensure .env file is in .gitignore.

    Args:
        env_path: Path to .env file
    """
    gitignore_path = env_path.parent / ".gitignore"

    # Check if .env is already ignored
    if gitignore_path.exists():
        content = gitignore_path.read_text()
        if ".env" in content:
            return

    # Add .env to .gitignore
    with open(gitignore_path, "a") as f:
        f.write("\n# MCP Server Credentials (added by InstructionKit)\n")
        f.write(".env\n")


def merge_env_configs(project_config: EnvironmentConfig, global_config: EnvironmentConfig) -> EnvironmentConfig:
    """
    Merge project and global environment configurations.

    Project variables take precedence over global variables.

    Args:
        project_config: Project-scoped environment config
        global_config: Global-scoped environment config

    Returns:
        Merged EnvironmentConfig with project taking precedence
    """
    merged_variables = {}

    # Start with global variables
    merged_variables.update(global_config.variables)

    # Override with project variables
    merged_variables.update(project_config.variables)

    return EnvironmentConfig(
        variables=merged_variables, file_path=project_config.file_path, scope=InstallationScope.PROJECT
    )
